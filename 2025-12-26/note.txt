github는 MS(Azure, AWS, GCP)가 먹었다
-> vscode- github와 연동
호환잘됨

Cursor ai= vscode 기반 -> ai라는 껍데기하나 더 씌운것


====여기 깐 확장플러그인====
azure Repos,Better Comments,dracula thema official,indent-rainbow
live server

git graph
git history
github repositories
github pull requests
project manager

치트아닌 유틸리티적인 도구들을 자유롭게 설치하고 삭제하는 장점을 누려보기
vscode -github 계정연결 (톱니바퀴위에)

github copilot
고글쓴 걔
MS Copilot친구랑 다름 (얘는 웹/ms앱들 위주)
ask/plan모드 권장

에이전트빌드 패널(창)켜기: ctrl + shift + i



훈련간 원칙(훌륭하고 강한 개발자를 만들기 위해서)
1.llm 아예 맡긴 상태(자유롭게)
2.내가 부분부분 이해하고 있는 상태(신경써서)
3.llm 없이 쓸 수 있는 상태(해내야만할것)
{강사이름}라면 아주 작은것(부담스럽지 않은것만)사용할것
최초기획은 절대 llm에게 맡기지 않을것
항상 '내가' 만들고=>보조로만 쓸것

2. '성공 경험'의 부재
개발 공부에서 가장 중요한 건 "어? 이게 되네?" 하는 작은 성공의 반복입니다.

AI가 짜준 코드를 붙여넣어서 실행되면 그건 AI의 성공이지 나의 성공이 아닙니다.

1. "내가 짠 코드" vs "AI가 준 코드"의 차이
내가 짠 코드: 어디가 약점인지, 왜 이 줄을 썼는지 내 머릿속에 지도가 있습니다. 에러가 나도 "아, 아까 거기?" 하고 바로 찾아갈 수 있죠.

AI가 준 코드: 블랙박스입니다. 겉보기에 멀쩡해 보여도 에러가 나면 1행부터 100행까지 전부 남의 코드를 검수해야 합니다. 이 과정에서 학습 효율은 떨어지고 스트레스만 극대화됩니다.

비싼 모델은 언제 쓸까?
-> 내 작업을 '점검'할 때 통렬한 비판을 해줄수 있음

시작은 항상 '사람'이 먼저 한다
서포트가 LLM이 된다.
'책임' 때문에 종료도 '사람'이 한다.

====오늘 할일====
1.CRUD, Class, method -> 어떻게 상호유기적으로 구성되어있는지 파악해보기
2.function과 method는 뭔 차이가 있는가?

지난날에 해본 것들을 method화 시킬 수 있는가?
=> 이것이 왜 중요한가? 내가 선배개발자이면 이를 후배개발자에게 어떻게 가르쳐줄 수 있나?


====================================================================
CRUD = 스마트도서관 기계가 새책을 등록하거나, 읽게해주거나, 책정보를 수정하거나, 책을 삭제하거나 해준다.
Class, method = 그 기계의 부품? <==class 입장에서는 별로 적절하진 않음

<어떻게 재정의할 수 있을까?>
Class = 책 뱉어주는 기계의 디지털 설계도. 둔산동에 있는 기계와 법동에 있는 기계등
method = 기계의 각 기능들: 예시) 책 추가하기(Create) 버튼을 누르면 책 정보를 등록하고 추가해주는 기능을 수행해준다.


상황 설정: 나는 '기계 설계하고 만드는 회사'에 다니는 인간이다.
Class가 없음 => 같은 기계를 10개 생산해야해서 하나하나 양산했는데, 그 이후 구조에 뒤늦게 결함이 발견되면 그 기계 10개를 고치러 일일히 돌아다님
Class가 있음 => 각 10개의 기계들이 클래스 하나에 연동됨. (좀 비현실적이지만 현실과 디지털이 연결되어있다고 침) 클래스 하나만 수정하면 모든 기계를 한번에 고치기가 가능함

-에디터로 코드 쓰고 있는 '나'의 관점-그냥 복사 붙여넣기 해서 둔산동 기계 하나 만들고, 법동 기계 하나 만들면 안되는가?
= 복사 붙여넣기는 직접 써가며 어떤 서류를 하나하나 손복사하는 것(노가다), Class는 디지털 파일을 하나 만들어 인쇄해서 한번에 여러 개 공유하는 것
"똑같은 일 두번 하지 말자"

함수와 메서드의 차이
어디에 속해있느냐가 핵심
함수 (Function)                           | 메서드 (Method) 비교
소속: 어디에도 속하지 않은 독립적 존재       | 클래스(기계) 내부에 소속됨
호출 방식: 이름만 부르면 실행 (calculate()) | 기계를 통해야 실행 (machine.rent())
관계: 데이터와 독립적인 경우가 많음         | 기계 내부의 데이터와 긴밀하게 소통함