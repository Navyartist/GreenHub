오늘노트

라이브러리를 파악하는 작업들이 어제의 작업이었다면
-> 내가알고있는 코어작성법을 '충분히 사용하는가' 체크해본다
생각보다 많이 어렵다
기어코 해낼 주요 미션 중 하나
사람말보다 코드로 이야기하는것이 편해지는 시점
일반인X 전문가O

예상 이점: 협업할 때 한명의 개발자가 주로 쓰는 패턴이나 습관들이 보인다.

의도를 읽으란 얘기

1. 객체 (dict)
2. 배열 (list)
3. 함수 (def)
4. 생성자 (class)
5. 메서드 (method)
6. 조건 (if)
7. 반복 (for, while)
8. 모듈화 (module)



굉장히 중요한 코어 작성 - 즉 logic 작성
거의 불변
언어를 바꿔도 거의 지장이 없는 부분
개발자마다, 프로젝트마다 매우 상이한 편
코드 '잘쓴다' 라는 인정은 이부분에 해당
=> 이를 개발자들 사이에서 표현하는 어휘: '모델링' 했다.

modeling => 프로그래밍에 해당되는 작업
'기획 투과' = 어지간하면 변하지 않아야함
하나를 더 만드는 한이 있어도, 변하는 것은 좋지 많을 때가 많음

renderer는 '표현'의 수단. 필요에 따라 언제든지 변할 수 있음

☆모델링과 렌더러의 구별

표현수단은 남의것이니까 내가 굳이 머리싸매지 않는다. 그러나 투과할 나의 의도는 100% 주도권을 쥐고있는다


view (렌더러) : 표현파트, 뷰파트
model (논리) : 논리파트, 모델파트, developer(개발자 그 자체)
controller (조절장치) : 약속, 실행파트, 조절파트

1. 처음 아무렇게나 한다. (조건따지지 않는다)
-> 스파게티 코드를 짠다. 내 맘대로 짠다.
2. 최초 동작하는지를 본다. (창부터 띄운것)
-> 안전해짐, 디버깅도 가능해짐 - 소거법 성립
-> 이래도 되나 싶을 정도로 가볍게 -> 궤도 돌듯이
3. 코드에 대해서 파트를 분별 => 동작하는지 또 확인
-> 내가 신경쓸 파트와 안써도 되는 파트를 구분
4. '모델링' 파트 부분 만큼은 온전히, 그이상 내것이어야 한다.
-> 승부수를 걸 부분 (코딩, 순서짜는)
-> 상당히 독립적으로 동작해야함 -> 이걸 '순수하다' 고 함 (pure)
5. 정돈 -> 1년, 5년뒤를 보는 꼼꼼함


모델러와 렌더러의 차이를 정의해보기
좋은 코드와 나쁜 코드의 예제를 찾아보기
일상의 표현들을 -> 기본 문법(syntax)으로 작성하기
풀어내는 방식은 맘대로 해보기 (grammer)


캡슐화 => 뽑기(알), 알약

필요한 요소들을 '나열' 하는 행위
필요한 '기능' 들도 같이 넣어서

한데 묶어 사용하는 행위
프로그래밍의 굉장히 메인 뭐시기
@@@@@@@@

어제해본거 '코어 문법'으로 분리해보기
'제목' + '내용' + '저장' + '조회' -> 앱 만들 예정 (금요일에)
cli, gui, 다른언어든 기본이든 -> 4가지를 충족해보는 연습

======================================================

<코어 문법>
디데이 확인 앱을 어떻게 8가지로 분리할까?
1. 객체 (dict) 디데이 일수 + 이벤트 날짜 모음
2. 배열 (list) 디데이 계산할 객체가 여러 개
3. 함수 (def) # today(오늘 날짜)는 모든 객체에서 동일하게 사용하니까 today 함수, 조건에 따라 기호를 바꾸는 함수('+'와 '-')
4. 생성자 (class) 만들 객체들의 뼈대가 되는 설계도
5. 메서드 (method) # 객체 내에서 날짜를 계산해주는 함수 (디데이 일수 계산)
6. 조건 (if) 이벤트 날짜가 지났냐, 안 지났냐 구분
7. 반복 (for, while) 각 객체의 디데이 계산을 반복
8. 모듈화 (module) # datetime 라이브러리(today 함수) 또는 datetime 라이브러리를 쓴 내 커스텀 모듈. 디데이 일수의 부호값에 따라 특정 기호를 반환해주는 기능을 가진 모듈

<제목, 내용, 저장, 조회>
제목: '데이터' 를 찾기 위한 이름표
내용: 이름표에 연결된, 우리가 실제 쓰고자하는 데이터(키값)
저장: 기록(Write, Save) 어딘가에 이를 기록(데베, 메모리등)
조회: 데이터를 실제로 조회

제목: 이벤트날짜, 디데이일수, 이벤트이름(ex: 구정)
내용: 
    이벤트날짜- 2026.02.17
    디데이일수- 49일(오늘 날짜가 2025.12.30인 기준) 수식으로 하면 [이벤트 날짜-오늘 날짜],
    이벤트이름- 구정

저장: 디데이 일수를 계산해서 변수 '디데이'에 저장
조회: 디데이를 보여줌(tkinter, 창과 내 데이터를 보여줄 수 있도록 연결)

<스파게티 코드 만든 후 첫 리뷰>
잘된 점
    직관적
    단순하고 심플함

아쉬운 점
    메서드, 모듈, 함수, 클래스 구분짓는게 부실
    데이터 요소가 1가지만 있을 경우만 고려


<모델러와 렌더러>
view (렌더러) : 표현파트, 뷰파트
model (논리) : 논리파트, 모델파트, developer(개발자 그 자체)
controller (조절장치) : 약속, 실행파트, 조절파트

1. 모델러 (Modeler): "책의 논리적 설계자"
모델러는 책의 겉모습이 아니라, 책 속에 담길 정보의 규칙과 논리를 만드는 사람입니다.

하는 일: "책에는 반드시 '제목', '저자', '발행일', '페이지 수'가 있어야 해"라고 정의하는 것.

프로그래밍에서의 역할: 데이터의 구조(Class, DB Schema)를 설계합니다. 속성(제목, 저자등)을 결정하는 것이 바로 모델링입니다.

핵심: 눈에 보이지 않는 데이터의 본질과 관계를 다룹니다. (내부 논리)

2. 렌더러 (Renderer): "책의 편집 디자이너"
렌더러는 모델러가 만든 딱딱한 데이터를 사용자가 보기 좋게 화면에 그려내는 사람입니다.

하는 일: "제목은 빨간색 큰 글씨로 왼쪽 위에 두고, 내용은 나눔고딕 글꼴로 배치해!"라고 결정하는 것.

프로그래밍에서의 역할: GUI(Tkinter, HTML/CSS)를 통해 데이터를 시각화합니다. Label의 색상, Button의 위치, 애니메이션 효과 등을 담당합니다.

핵심: 사용자에게 어떻게 보여줄 것인가를 다룹니다. (외부 표현)

모델러: 프로그램의 로직, 내부 논리를 만드는 사람(기획 역할)
렌더러: 로직 결과에 따라 보이는 걸 만드는 사람(글씨의 크기나 색, 배치등. 디자이너 역할)

둘의 구분은 왜 중요한가? (창업가 관점)
창업자가 이 둘을 섞어버리면 나중에 서비스 수정이 어려워진다.


<좋은 코드와 나쁜 코드>
    좋은 코드: 함께 협업하기 좋은 코드. 보기 쉬운 코드, 모델러와 렌더러등의 구분이 잘 되어있는 코드 등

<일상의 표현을 기본 문법으로 써보기>
일상을 코드화하기: 버스를 탈 때
    if 버스카드 잔액이 없음:
        if 계좌이체를 함:
            버스 탑승
        else:
            버스에서 내림
    else:
        버스에 탑승함